/* tslint:disable */
/* eslint-disable */
/**
 * Open Food Facts Open API
 * As a developer, the Open Food Facts API allows you to get information and contribute to the products database. You can create great apps to help people make better food choices and also provide data to enhance the database.
 *
 * The version of the OpenAPI document: 2
 * Contact: reuse@openfoodfacts.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  AddOrEditAProductResponse,
  AddPhotoToExistingProductResponse,
  RotateAPhotoResponse,
} from "../models/index";
import {
  AddOrEditAProductResponseFromJSON,
  AddOrEditAProductResponseToJSON,
  AddPhotoToExistingProductResponseFromJSON,
  AddPhotoToExistingProductResponseToJSON,
  RotateAPhotoResponseFromJSON,
  RotateAPhotoResponseToJSON,
} from "../models/index";

export interface GetCgiProductImageCropPlRequest {
  code: string;
  id: string;
  imgid: string;
  angle: string;
}

export interface GetCgiProductImageUploadPlRequest {
  code: string;
  imagefield: string;
  imgupload_front_en: Blob;
}

export interface PostCgiProductImageCropPlRequest {
  code: string;
  imgid: number;
  id: string;
  x1?: number;
  y1?: number;
  x2?: number;
  y2?: number;
  angle?: number;
  normalize?: PostCgiProductImageCropPlNormalizeEnum;
  white_magic?: PostCgiProductImageCropPlWhiteMagicEnum;
}

export interface PostCgiProductJqm2PlRequest {
  code: string;
  user_id: string;
  password: string;
  comment?: string;
  brands?: Array<string>;
  labels?: Array<string>;
  categories?: Array<string>;
  packaging?: string;
  app_name?: string;
  app_version?: string;
  app_uuid?: string;
  User_Agent?: string;
}

/**
 *
 */
export class WriteRequestsApi extends runtime.BaseAPI {
  /**
   * Although we recommend rotating photos manually and uploading a new version of the image, the OFF API allows you to make api calls to automate this process. You can rotate existing photos by setting the angle to 90º, 180º, or 270º clockwise.
   * Rotate A Photo
   */
  async getCgiProductImageCropPlRaw(
    requestParameters: GetCgiProductImageCropPlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<RotateAPhotoResponse>> {
    if (requestParameters["code"] == null) {
      throw new runtime.RequiredError(
        "code",
        'Required parameter "code" was null or undefined when calling getCgiProductImageCropPl().',
      );
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getCgiProductImageCropPl().',
      );
    }

    if (requestParameters["imgid"] == null) {
      throw new runtime.RequiredError(
        "imgid",
        'Required parameter "imgid" was null or undefined when calling getCgiProductImageCropPl().',
      );
    }

    if (requestParameters["angle"] == null) {
      throw new runtime.RequiredError(
        "angle",
        'Required parameter "angle" was null or undefined when calling getCgiProductImageCropPl().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["code"] != null) {
      queryParameters["code"] = requestParameters["code"];
    }

    if (requestParameters["id"] != null) {
      queryParameters["id"] = requestParameters["id"];
    }

    if (requestParameters["imgid"] != null) {
      queryParameters["imgid"] = requestParameters["imgid"];
    }

    if (requestParameters["angle"] != null) {
      queryParameters["angle"] = requestParameters["angle"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/cgi/product_image_crop.pl`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      RotateAPhotoResponseFromJSON(jsonValue),
    );
  }

  /**
   * Although we recommend rotating photos manually and uploading a new version of the image, the OFF API allows you to make api calls to automate this process. You can rotate existing photos by setting the angle to 90º, 180º, or 270º clockwise.
   * Rotate A Photo
   */
  async getCgiProductImageCropPl(
    requestParameters: GetCgiProductImageCropPlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<RotateAPhotoResponse> {
    const response = await this.getCgiProductImageCropPlRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Photos are source and proof of data. The first photo uploaded for a product is auto-selected as the product’s “front” photo.\'
   * Add a Photo to an Existing Product
   */
  async getCgiProductImageUploadPlRaw(
    requestParameters: GetCgiProductImageUploadPlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AddPhotoToExistingProductResponse>> {
    if (requestParameters["code"] == null) {
      throw new runtime.RequiredError(
        "code",
        'Required parameter "code" was null or undefined when calling getCgiProductImageUploadPl().',
      );
    }

    if (requestParameters["imagefield"] == null) {
      throw new runtime.RequiredError(
        "imagefield",
        'Required parameter "imagefield" was null or undefined when calling getCgiProductImageUploadPl().',
      );
    }

    if (requestParameters["imgupload_front_en"] == null) {
      throw new runtime.RequiredError(
        "imgupload_front_en",
        'Required parameter "imgupload_front_en" was null or undefined when calling getCgiProductImageUploadPl().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["User-Agent"] =
        await this.configuration.apiKey("User-Agent"); // userAgentAuth authentication
    }

    const consumes: runtime.Consume[] = [
      { contentType: "multipart/form-data" },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters["code"] != null) {
      formParams.append("code", requestParameters["code"] as any);
    }

    if (requestParameters["imagefield"] != null) {
      formParams.append("imagefield", requestParameters["imagefield"] as any);
    }

    if (requestParameters["imgupload_front_en"] != null) {
      formParams.append(
        "imgupload_front_en",
        requestParameters["imgupload_front_en"] as any,
      );
    }

    const response = await this.request(
      {
        path: `/cgi/product_image_upload.pl`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AddPhotoToExistingProductResponseFromJSON(jsonValue),
    );
  }

  /**
   * Photos are source and proof of data. The first photo uploaded for a product is auto-selected as the product’s “front” photo.\'
   * Add a Photo to an Existing Product
   */
  async getCgiProductImageUploadPl(
    requestParameters: GetCgiProductImageUploadPlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AddPhotoToExistingProductResponse> {
    const response = await this.getCgiProductImageUploadPlRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Cropping is only relevant for editing existing products. You cannot crop an image the first time you upload it to the system.
   * Crop A Photo
   */
  async postCgiProductImageCropPlRaw(
    requestParameters: PostCgiProductImageCropPlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<object>> {
    if (requestParameters["code"] == null) {
      throw new runtime.RequiredError(
        "code",
        'Required parameter "code" was null or undefined when calling postCgiProductImageCropPl().',
      );
    }

    if (requestParameters["imgid"] == null) {
      throw new runtime.RequiredError(
        "imgid",
        'Required parameter "imgid" was null or undefined when calling postCgiProductImageCropPl().',
      );
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling postCgiProductImageCropPl().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const consumes: runtime.Consume[] = [
      { contentType: "multipart/form-data" },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters["code"] != null) {
      formParams.append("code", requestParameters["code"] as any);
    }

    if (requestParameters["imgid"] != null) {
      formParams.append("imgid", requestParameters["imgid"] as any);
    }

    if (requestParameters["id"] != null) {
      formParams.append("id", requestParameters["id"] as any);
    }

    if (requestParameters["x1"] != null) {
      formParams.append("x1", requestParameters["x1"] as any);
    }

    if (requestParameters["y1"] != null) {
      formParams.append("y1", requestParameters["y1"] as any);
    }

    if (requestParameters["x2"] != null) {
      formParams.append("x2", requestParameters["x2"] as any);
    }

    if (requestParameters["y2"] != null) {
      formParams.append("y2", requestParameters["y2"] as any);
    }

    if (requestParameters["angle"] != null) {
      formParams.append("angle", requestParameters["angle"] as any);
    }

    if (requestParameters["normalize"] != null) {
      formParams.append("normalize", requestParameters["normalize"] as any);
    }

    if (requestParameters["white_magic"] != null) {
      formParams.append("white_magic", requestParameters["white_magic"] as any);
    }

    const response = await this.request(
      {
        path: `/cgi/product_image_crop.pl`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Cropping is only relevant for editing existing products. You cannot crop an image the first time you upload it to the system.
   * Crop A Photo
   */
  async postCgiProductImageCropPl(
    requestParameters: PostCgiProductImageCropPlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<object> {
    const response = await this.postCgiProductImageCropPlRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * This updates a product.  Note: If the barcode exists then you will be editing the existing product, However if it doesn\'\'t you will be creating a new product with that unique barcode, and adding properties to the product.
   * Add or Edit A Product
   */
  async postCgiProductJqm2PlRaw(
    requestParameters: PostCgiProductJqm2PlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AddOrEditAProductResponse>> {
    if (requestParameters["code"] == null) {
      throw new runtime.RequiredError(
        "code",
        'Required parameter "code" was null or undefined when calling postCgiProductJqm2Pl().',
      );
    }

    if (requestParameters["user_id"] == null) {
      throw new runtime.RequiredError(
        "user_id",
        'Required parameter "user_id" was null or undefined when calling postCgiProductJqm2Pl().',
      );
    }

    if (requestParameters["password"] == null) {
      throw new runtime.RequiredError(
        "password",
        'Required parameter "password" was null or undefined when calling postCgiProductJqm2Pl().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["User-Agent"] =
        await this.configuration.apiKey("User-Agent"); // userAgentAuth authentication
    }

    const consumes: runtime.Consume[] = [
      { contentType: "multipart/form-data" },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters["code"] != null) {
      formParams.append("code", requestParameters["code"] as any);
    }

    if (requestParameters["user_id"] != null) {
      formParams.append("user_id", requestParameters["user_id"] as any);
    }

    if (requestParameters["password"] != null) {
      formParams.append("password", requestParameters["password"] as any);
    }

    if (requestParameters["comment"] != null) {
      formParams.append("comment", requestParameters["comment"] as any);
    }

    if (requestParameters["brands"] != null) {
      formParams.append(
        "brands",
        requestParameters["brands"]!.join(runtime.COLLECTION_FORMATS["csv"]),
      );
    }

    if (requestParameters["labels"] != null) {
      formParams.append(
        "labels",
        requestParameters["labels"]!.join(runtime.COLLECTION_FORMATS["csv"]),
      );
    }

    if (requestParameters["categories"] != null) {
      formParams.append(
        "categories",
        requestParameters["categories"]!.join(
          runtime.COLLECTION_FORMATS["csv"],
        ),
      );
    }

    if (requestParameters["packaging"] != null) {
      formParams.append("packaging", requestParameters["packaging"] as any);
    }

    if (requestParameters["app_name"] != null) {
      formParams.append("app_name", requestParameters["app_name"] as any);
    }

    if (requestParameters["app_version"] != null) {
      formParams.append("app_version", requestParameters["app_version"] as any);
    }

    if (requestParameters["app_uuid"] != null) {
      formParams.append("app_uuid", requestParameters["app_uuid"] as any);
    }

    if (requestParameters["User_Agent"] != null) {
      formParams.append("User-Agent", requestParameters["User_Agent"] as any);
    }

    const response = await this.request(
      {
        path: `/cgi/product_jqm2.pl`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AddOrEditAProductResponseFromJSON(jsonValue),
    );
  }

  /**
   * This updates a product.  Note: If the barcode exists then you will be editing the existing product, However if it doesn\'\'t you will be creating a new product with that unique barcode, and adding properties to the product.
   * Add or Edit A Product
   */
  async postCgiProductJqm2Pl(
    requestParameters: PostCgiProductJqm2PlRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AddOrEditAProductResponse> {
    const response = await this.postCgiProductJqm2PlRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}

/**
 * @export
 */
export const PostCgiProductImageCropPlNormalizeEnum = {
  true: "true",
  false: "false",
} as const;
export type PostCgiProductImageCropPlNormalizeEnum =
  (typeof PostCgiProductImageCropPlNormalizeEnum)[keyof typeof PostCgiProductImageCropPlNormalizeEnum];
/**
 * @export
 */
export const PostCgiProductImageCropPlWhiteMagicEnum = {
  true: "true",
  false: "false",
} as const;
export type PostCgiProductImageCropPlWhiteMagicEnum =
  (typeof PostCgiProductImageCropPlWhiteMagicEnum)[keyof typeof PostCgiProductImageCropPlWhiteMagicEnum];
